\section{Struttura del codice sorgente}\label{sec:Struttura_Codice}
Al fine di fornire un codice ben organizzato, data la media dimensione in termini di righe di codice del software sviluppato, si è deciso dal principio di strutturarlo in \textbf{moduli} e \textbf{sottomoduli}. Il seguente schema ne mostra l'organizzazione.\\
{
\large{
    \dirtree{%
    .1 src/.
    .2 hardened \ldots\ldots\ldots\ldots\ldots\ldots{} \begin{minipage}[t]{10cm}
                            Definizione e implementazione del tipo \texttt{Hardened<T>}; definizione del tipo enumerativo \texttt{IncoherenceErorr}\\
                          \end{minipage} . 
    .2 fault\_list\_manager \ldots\ldots\ldots{} \begin{minipage}[t] {10 cm}
        Generazione della fault list\\
    \end{minipage}.
    .3 static\_analysis \ldots\ldots\ldots{} \begin{minipage}[t]{10cm}
          Analisi statica automatica del codice\\
    \end{minipage}.
    .2 injector \ldots\ldots\ldots\ldots\ldots\ldots{} \begin{minipage}[t]{10cm}
        Iniettore dei fault\\
    \end{minipage}.
    .3 algorithms \ldots\ldots\ldots\ldots\quad{} \begin{minipage}[t]{10cm}
        Adattamento del codice dei tre casi di studio alla fault injection software\\
    \end{minipage}. 
    .2 analizer \ldots\ldots\ldots\ldots\ldots\ldots{} \begin{minipage}[t]{10cm}
        Calcoli di aggregati e statistiche, analisi dei risultati, generazione di report in pdf
    \end{minipage}.
}
}
}

\vspace{0.5em}
\noindent
Per ogni modulo, sono stati scritti dei \textbf{test d'unità} conformi al \textbf{paradigma AAA} (Arrange, Act, Assert), questo al fine di verificare che tutte le funzioni implementate dessero i risultati desiderati. Al fine di essere quanto più allineati con le convenzioni adottate dalla comunità di sviluppatori Rust, ognuno dei moduli ha un sottomodulo \texttt{tests} definito come segue: 

\begin{lstlisting}[language=rust, style=boxed]
#[cfg(test)]
mod tests{
    #[test]
    fn test_add_ok(){
        //Arrange
        let a = Hardened::from(3);
        let b = Hardened::from(2);
        //Act
        let c = (a+b);
        //Assert
        assert_eq!(c.is_ok(), true);
        assert_eq!(c.unwrap().inner().unwrap(), 5);
    }

    #[test]
    fn test_other(){
        unimplemented!()
    }
}
\end{lstlisting}
Dove \texttt{\#[cfg(test)]} permette di eseguire tutti i test relativi ad un modulo quando viene lanciato da terminale il comando \texttt{cargo test}.